# 性能优化类

## 性能测试

## 性能优化

### 网络资源加载优化

1. 减少 http 请求次数。懒加载，合并雪碧图，css 文件，js，CDN Combo，小图标转 base64 内嵌等
2. 减小 HTTP 请求大小。开启 gzip，压缩 js，css 文件，启用 http2，Cookie 隔离
3. 外链 CSS，js 文件，有利于缓存改动较小 css，js 文件，减少网络请求
4. 避免空的 src，href 等，依然会进行网络请求，直到失败阻塞其他网络请求
5. 使用 Cache-Control，ETag，Last-Modified 进行缓存
6. 静态资源分域存在，增加并行下载数
7. CDN 加速
8. 缓存 Ajax 请求
9. 异步加载 JavaScript 资源
10. DNS 预解析，同 prefetch 属性
11. 单张图片不超过 30 KB

### 页面渲染类

1. 置顶 CSS 资源，置尾 js 资源，是为了让 js 不阻塞页面渲染
2. 减少 DOM 的深度
3. 避免使用 table 和 iframe 表情，table 是全部渲染完成，一次绘制，因此在长表格时很耗性能

#### 回流和重绘

常见重绘场景

1. 更改 DOM 的几何属性，如 width，height，padding，margin 等。为耗时操作
2. 获取即时属性。offsetTop，scrollTop，clientTop，getComputedStyle 等
3. 更改 DOM 结构，如移动节点位置等

避免回流，减少重绘，核心思想与优化 DOM 一致

1. 缓存样式改动，把改动用一个 js 对象缓存起来，再一起应用
2. 用 class 合并多个样式的改动，替代一条条 style 改动
3. 离线 DOM，使用 display:none，把 DOM 离线，经过频繁的改动后，再用 display:block 重新渲染

#### DOM 为什么慢

1. 修改 DOM 需要 js 引擎和渲染引擎进行通信，需要一定通信成本
2. 修改 DOM 时触发的回流重绘同样导致渲染速度变慢
   1. 回流即 DOM 几何属性的变化，如修改元素宽高，隐藏元素等，浏览器需要重新计算元素的几何属性。因为在渲染树的布局（回流）阶段，浏览器时需要精密计算出每一个节点的位置，大小属性。反而言之，需要重新计算位置和大小，那么就回到了回流阶段
   2. 重绘。也就是对应浏览器渲染中的绘制图层阶段，把DOM 图层转换为像素点，如颜色，背景等

#### DOM 优化

1. 减少 DOM 操作次数，如要插入一百条记录，不能插一百次，而是先用 js 生成一百条相关文档，然后一次插入到 DOM 中
2. 缓存 DOM 操作，使用 DOM Fragment 缓存 js 对于 DOM 节点的操作，比如在先把一百记录插到 DOM Fragment 中，在将 DOM Fragement 插入 DOM 中。又如如果一个元素进行了增删增操作，实际上只需要一次增操作，我使用 DOM Fragement 进行增删增之后，再进行更新。
3. 异步更新策略。一个 Event-Loop 会经过。macro-task -> micro-task -> 渲染更新 -> 检查&& 执行 WebWoker。因此在异步更新的策略中，把更新任务放在 micro-task 里面可以最靠近渲染步骤，从而尽快地更新。而放在宏任务中，需要等下一轮的渲染

### 移动端常见优化

1. 首屏数据提前请求
2. 首屏按需加载，非首屏滚动加载，懒加载。首屏数据大小总共不超过 1MB
3. 内联必备的 CSS 和 JavaScript

### webpack 构建优化

webpack 打包主要围绕着两个问题，一是构建速度的问题，而是打包体积的问题

### 构建速度优化

1. 启用缓存。如 babel 可以将转译结果缓存到文件系统

2. DllPlugin，借鉴了 windows 动态连接库的思想，把可以把第三方库打包到一个单独的文件中，只有依赖发生变化时才会重新打包，从而解决 CommonsChunkPlugin 每次构建都重新构建一次 vendor 的问题
3. happy pack 多线程打包

### 构建体积优化

1. 拆分资源。如 CommonsChunkPlugin 可以把公用的依赖打包到一个chunk，从而防止重复打包依赖。拆分资源也有体积缩小和按需加载
2. 删除冗余代码。tree-shaking，可以在编译过程中删除在上下文中未引用到的代码，依赖于 ES6 的 import/export 静态结构特性。tree-shaking 仅进行标记，故也需要一个能够删除未引用代码的插件如 UglifyJSPlugin
3. 按需加载。如 webpack import()，和 require.ensure 会在这个语句执行时创建一个入口端点，这个模块以及其子模块就会被单独打包到一个文件中。

## 图片优化

1. jpg 有损失压缩，压缩比大，色彩丰富，使用于大图
2. png 无损压缩，色彩多，支持透明度，适用于边缘感强，带透明度的小图标
3. svg 优点是文件体积小，矢量图形，放大不失真，可编程，缺点是占用渲染成本，一定学习成本
4. Base64 和 CSS Sprites。Base64，是一种编码方式，通过把小图转 base64 格式，嵌入到 html 中，从而减少 http 请求次数，适用 2Kb 以下，不经常改变的小图标。CSS Sprites，把多个形状规则的小图标合成一张大图，通过 background-position 去定位图标，主要目的是为了减少 http 请求次数
5. webp。集有多种图片格式的优点于一身，支持色彩丰富，压缩比高，支持透明度，支持动态图片。缺点是兼容性差，仅谷歌的支持性好。可以在前端采用降级方案，如果不支持 webp 就降级成 jpg。如淘宝采用 xxx.jpg.webp 这种格式，在检测到不支持 webp 时，就去掉 .webp 从而去请求 jpg 格式

## 服务端渲染 SSR

客户端渲染，即 dom 和 内容由客户端浏览器跑 js 生成。

服务端渲染，即服务器把需要的组件或页面渲染成 html 字符，然后返回给客户端，客户端拿到的就是直接可渲染然后可以呈现给用户的 html 内容，不需要再去为了生成 dom 再去跑一遍 js

### 客户端渲染优缺点

有利于减少服务器压力，充分利用浏览器资源。缺点是不利于 SEO 优化，不利于首屏的加载。

### 服务端渲染的优缺点

有利于 SEO，首屏加载。缺点是大大增大了服务端的压力